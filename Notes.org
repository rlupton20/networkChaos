* Dummy Network Interfaces
** To create a dummy interface:

sudo modprobe dummy
sudo ip link add rvl0 type dummy
sudo ifconfig rvl0 up

route add -net 10.0.0.0 netmask 255.255.255.0 dev rvl0

** To take the dummy interface down:

route delete -net 10.0.0.0 netmask 255.255.255.0 dev rvl0

sudo ifconfig rvl0 down
sudo ip link delete rvl0 type dummy
sudo rmmod dummy
* Sockets
** Raw Sockets
IPPROTO_RAW is protocol number 255.
* Running list of requirements
** libpcap development library
Operating System's package manager
** pcap
cabal install pcap
** dummy kernal module
Should be preinstalled
** network-house package
cabal-install network-house
* Notes and resources
http://www.pocketnix.org/posts/Linux%20Networking:%20Dummy%20Interfaces%20and%20Virtual%20Bridges
http://unix.stackexchange.com/questions/152331/how-can-i-create-a-virtual-ethernet-interface-on-a-machine-without-a-physical-ad
** Parsing packets with the Haskell house library
http://osdir.com/ml/lang.haskell.libraries/2006-05/msg00076.html
** List of useable IP addresses for LAN
http://www.arrowmail.co.uk/articles/iprange.aspx
* Generating SSL (TSL) keys and certificates
From the command line, the following is a good starting point
openssl req -x509 -newkey rsa:2048 -keyout key.pem -out cert.pem -days 30

Clients also expect the hostname and common name to agree (when setting ClientParams). Certificates need to abide by this.

Clients also need to know whether they can trust a certificate or not.
Add trusted certificates to Shared's sharedCAStoreCertificates can be loaded using readSignedObject (Data.X509.File), and translated to CertificateStore by makeCertificateStore (Data.X509.CertificateStore).
* Commuicating certificates
Could use a SHA hash to pass condensed certificate check to others.
ClientHooks can be used on receipt of a certificate, to check it against a hash, and add it to a database.
* TLS sockets
To get TLS working: use contextNew backend params    --randomNumGen?
NOTE: A context should be made on a connection with a client, not
just a listening socket.
params : Client params and Server params
serverParams = ServerParams ...
https://hackage.haskell.org/package/tls-1.2.2/docs/Network-TLS.html#g:6
Socket is an instance of HasBackend, so contextNew can be passed a socket.
ClientParams is an instance of TLSParams, as is ServerParams (missing from documentation, but ghci confirms).
NOTE: contextNew doesn't appear to need a random number generator. Where on earth did I find CPRG?
** ServerParams
ServerParams = ServerParams {
serverWantClientCert :: Bool,
serverCACertificates :: [SignedCertificate],
serverDHEParams :: Maybe DHParams,
serverShared :: Shared,
serverHooks :: ServerHooks,
serverSupported :: Supported }

Can get defaults by using def from Data.Default.Class
** ClientParams
** Reading certificates
The old Network.TLS.Extra provides:
fileReadCertificate :: FilePath -> IO X509
fileReadPrivateKey :: FilePath -> IO PrivateKey
This is replaced by:
credentialLoadX509 :: FilePath -> FilePath -> IO (Either String Credential)
Note passphrases make this fail, remove passphrases with
openssl rsa -in keyIn.pem -out keyNoPassphrase.pem
or see
http://serverfault.com/questions/366372/is-it-possible-to-generate-rsa-key-without-pass-phrase
The option -nodes (No DES) will stop the key being encrypted.

Then credentialLoadX509 "cert.pem" "key.pem" loads the certificate.

Since on the fly (non-interactive) generation is also desirable, one can do this.
E.g.
http://crohr.me/journal/2014/generate-self-signed-ssl-certificate-without-prompt-noninteractive-mode.html
http://unix.stackexchange.com/questions/104171/create-ssl-certificate-non-interactively
** Random number generator for Cryptography
SystemRNG is probably enough (looking for an instance of CPRG)
Actually, not required for contextNew
** Sending data
Using {-# LANGUAGE OverloadedStrings #-} with import Data.String to use ByteStrings with fromString (i.e. abstract string datatype ala Num)
* Datagram TLS
DTLS is for unreliable transport protocols. May be useful for tunneling UDP etc.
* Sockets
aNY_PORT can be passed as a port number if a dynamically allocated port is required. Since I need many connections this is useful. There are functions available to discover this number also.
Since I want asynchronous communication, each correspondence will have
two sockets. It makes sense for these to be bound to a port to
simplify port mapping etc.
Also iNADDR_ANY for receiving from any interface (handy, since typically IP isn't static).
* UDP sockets
Need to manage these for tunnelling!
* UPnP (getting a peer-to-peer workable connection)
http://www.upnp-hacks.org/igd.html
* STUN protocol
Probably the way needed to get a peer-to-peer system up and running.
Haskell has the package stunclient, which provides the module Network.Stun
This required libicu-dev to be installed in order that dependency text-icu can be installed.
* Keeping peer-to-peer connections alive
Have separate(s) thread sending and receiving messages to each peer to keep connections alive.
* PPP Protocol
Point-to-point protocol, can be used to deliver packets. Good idea here?
* TURN protocol
If STUN fails then TURN.
Free (with sign up) TURN server
http://numb.viagenie.ca/
* cabal
https://downloads.haskell.org/~ghc/7.0.4/docs/html/Cabal/authors.html
* FFI and C
http://blog.bjrn.se/2008/09/speeding-up-haskell-with-c-very-short.html
* MTU
Don't want incoming packets (to be routed) to be too large to tunnel.
If the TUN devices MTU (Maximum Transmission Unit) is set low enough, then enough room should be preserved to add a header and send it.
* January 2016 todo list
** DONE Make ProcUnit exception safe (replaced with Stack and Buildable)
Wrapping Async might be the best way
** TODO Make Manager spawn exception safe threads
This can't use async (at least not in the same way). We don't want the program to suffer from these threads failing, but we want a clean shutdown, and consistent spawn list.
** TODO Tidy and check overall excpetion safety
Probably will follow from the above.

